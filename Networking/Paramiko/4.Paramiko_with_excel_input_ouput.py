import personal_login
from personal_login import main
my=main()
#Ignore this lines this is calling my personal logins from another file.please provide your logins below



#############################
#                            #
#      Step2success.in       #
#        copyright           #
##############################  
# pip install paramiko
# Paramiko is native library for SSH allother library are created on top of it.


import paramiko
import time

#Provide your login below
host=my['host']
login=my['login']
password=my['password']


client = paramiko.SSHClient()
client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
client.connect(hostname=host, username=login, password=password, look_for_keys=False, allow_agent=False)
# Use any of this Method 

############################################################################################################################
#  1. The exec command takes a command as an "argument" and executes it in an isolated environment without terminal emulation
# series of command not work in this which are dependent of each other. All command will run independently.
# much faster than Terminal
#############################################################################################################################

"""stdin , stdout, stderr = client.exec_command('pwd')
error = stderr.read()
data = stdout.read()
if error:
	print(error.decode("utf-8"))
    
if data:
	print("This output by Exec command",data.decode("utf-8"))"""
    


############################################################################################################################
#   2.  The shell channel executes a login shell (as if you login with SSH terminal client). The shell will then present a
#command prompt and wait for client/user to type the commands. The purpose of the shell channel is to implement an interactive shell session.
############################################################################################################################
import openpyxl
file_name='input.xlsx'
def write_excel(x,output):
	workbook_obj = openpyxl.load_workbook(file_name)
	sheet_obj = workbook_obj['Sheet1']
	sheet_obj.cell(row=x, column=4).value = output
	workbook_obj.save(file_name)

def write_text_file(device,output):
    a= open("Documents/{}.txt".format(device), "w")
    a.write(output)
    a.close()




def dynamic_wait(time_sleep_interval,max_time_sleep,parameter):
	output = str(shell_object.recv(999999))
	c=0

	while parameter not in output:
		time.sleep(time_sleep_interval)
		output = str(shell_object.recv(999999))
		c+1
		if c>max_time_sleep:
			break





def connect(router,command,s_id):
	print(s_id,router,command)
	shell_object = client.invoke_shell()
	time.sleep(1)
	shell_object.send(password+'\n')
	dynamic_wait(0.5,20,'Registered')

	cmd='l {}'.format(router)
	shell_object.send(cmd + "\n")
	dynamic_wait(0.5,20,'Device connected')


	
	
	#shell_object.send("sh ver | i uptime" + "\n")
	shell_object.send(command + "\n")
	time.sleep(2)
	output = str(shell_object.recv(999999).decode("utf-8"))

	print("This output is generated by Terminal: ", output)
	write_text_file(s_id,output)
	write_excel(s_id,output)


import pandas as pd
df=pd.read_excel('input.xlsx')

routers=df['switch']
commands=df['command']
s_ids=df['s_id']

for router,command,s_id in zip(routers,commands,s_ids):
	try:
		connect(router,command,s_id)
	except:
		pass

